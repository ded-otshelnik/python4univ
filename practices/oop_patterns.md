# Лабораторная работа 2. Паттерны объектно-ориентированного проектирования

Доминирующей парадигмой программирования на протяжении уже 30 лет является **объектно-ориентированное программирование (ООП)**. Большинство языков программирования так или иначе поддерживает хотя бы некоторые концепты ООП.

С повсеместным внедрением ООП в код многие программисты, которые практикуют данный подход, пришли к выводу, что необходимо систематизировать **шаблоны проектирования (design patterns)**. Исходя из этого, группа из 4-х программистов, прозванных позднее **Бандой четырех (Gang of four)**, Эрих Гамма, Ричард Хелм, Ральф Джонсон и Джон Влиссидесс, написала в 1994 году книгу **"Design Patterns: Elements of Reusable Object-Oriented Software"**, или **Паттерны объектно-ориентированного проектирования**, которая рассматривает преимущества и недостатки ООП, а также содержит описание 23 классических паттернов, которые продемонстрированы на примерах (хотя примеры эти написаны на языках С++ и Smalltalk). Книга уже является классической для разработчиков, так как паттерны, описанные в ней, применяются повсеместно.

## Концепции ООП: класс, объект, и т.д

Прежде, чем рассматривать паттерны ООП подробно, определим некоторые важные термины:

+ **Класс** - модель, по которой строятся объекты, описывающая их структуру (набор полей и начальное состояние) и связанные с классом алгоритмы (методы).

    ```python
    class MyClass:
        ...
    ```

+ **Объект** - экземпляр класса с собственным состоянием. Взаимодействовать с объектом можно через методы класса, к которому объект принадлежит.
  
    ```python
    my_object = MyClass()
    ```

+ **Состояние объекта** - данные (в том числе и ссылки на другие данные), которые храняться в объекте. Представляется в виде полей.
+ **Поведение объекта** - методы объекта, ассоциированного с конкретным классом.
+ **Инкапсуляция** - свойство системы, позволяющее объединить данные и методы, которые с ними работают, в классе, а также скрывать детали имплементации.

    ```python
    class MyClass:
        def __init__(self) -> None:
            self._private = 1
        
        def get_private(self) -> int:
            return self._private
    ```

+ **Абстракция** - набор общих характеристик объекта без описания их конкретных/детальных реализаций. Такой подход позволяет изменять реаизацию, не меняя способ взаимодействия с объектом.
+ **Наследование** - механизм, который позволяет новому классу (дочернему классу, классу-наследнику) *унаследовать* поведение уже существующего класса. В рамках отношений между классами описывается как "является" ("is")

    ```python
    class MySubClass(MyClass):
        ...
    ```

+ **Ассоциация** - ситуация, когда класс включает в себя как поле другой класс. В рамках отношений между классами описывается как "имеет/содержит" ("contains").
+ **Композиция** - частный случай ассоциации, когда класс, вложенный в другой класс, **полностью** управляется классом-"контейнером", т.е. объект вложенного класса не существует отдельно от внешнего класса.
+ **Агрегация** - частный случай ассоциации, когда класс, вложенные в другой класс, создается **вне основного класса** и передается в конструктор как параметр.
+ **Интерфейс** - класс-контракт, определяющий методы, которые **должны** быть определены в классах-наследниках.

    ```python
    class MyInterface(Protocol):
        def needed_method(self) -> str:
            ...
    ```

+ **Полиморфизм** - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

    ```python
    class ConcreteImplementationA:
        def needed_method(self) -> str:
            return "concrete_a"

    class ConcreteImplementationB:
        def needed_method(self) -> str:
            return "concrete_b"

    def polymorphic_function(obj: MyInterface) -> None:
        print(obj.needed_method())
    ```

## Паттерны объектно-ориентированного проектирования: классификация

**Паттерн проектирования** - высокоуровневое решение часто встречающейся проблемы при разработке программного обеспечения.

Согласно Банде четырех, паттерны проектирования делятся на 3 группы:

+ Порождающие паттерны:
  1. Одиночка (Singleton);
  2. Прототип (Prototype);
  3. Строитель (Builder);
  4. Абстрактная фабрика (Abstract Factory);
  5. Фабричный метод (Factory Method).
+ Структурные паттерны:
  1. Адаптер (Adapter);
  2. Декоратор (Decorator);
  3. Заместитель (Proxy);
  4. Компоновщик (Composer);
  5. Мост (Bridge);
  6. Приспособленец (Flyweight);
  7. Фасад (Facade).
+ Паттерны поведения:
  1. Интерпретатор (Interpreter);
  2. Шаблонный метод (Template method);
  3. Итератор (Iterator);
  4. Команда (Command);
  5. Наблюдатель (Observer);
  6. Посетитель (Visitor);
  7. Посредник (Mediator);
  8. Состояние (State);
  9. Стратегия (Strategy);
  10. Хранитель (Memento);
  11. Цепочка обязанностей (Chain of responsibilities).

Далее будут рассмотрены наиболее важные и популярные паттерны, которые могут встретиться при разработке программного обеспечения.

## Порождающие паттерны

**Порождающие паттерны** - паттерны, абстрагирующие процесс создания объектов. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов.

Для порождающих паттернов важны два аспекта: во-первых, паттерны инкапсулируют знания о конкретных классах, которые применяются в системе, во-вторых, они скрывают подробности создания и компоновки объектов классов. Единственная информация, которая известна - это интерфейсы, поэтому порождающие паттерны обеспечивают большую гибкость в отношении того, **что** создается, **кто** это создает, **как** и **когда**.

### Одиночка (Singleton)

**Одиночка** - порождающий паттерн, целью которого является гарантия существования только одного экземпляра класса, предоставляя к нему глобальную точку доступа.

Пусть есть класс:

```python
class Singleton:
    _instance: Optional[Singleton] = None

    def __new__(cls) -> Singleton:
        instance: Singleton
        if cls._instance is None:
            instance = object.__new__(cls)
            cls._instance = instance
        else:
            instance = cls._instance
        return instance
```

Благодаря паттерну класс будет работать следующим образом

```python
>>> singleton1 = Singleton()
>>> singleton2 = Singleton()
>>> singleton1 is singleton2
True
```

Преимущества паттерна:

+ Контролируемый доступ к единственному экземпляру;
+ Сокращение пространства имен;
+ Возможность уточнения операций и представления (через наследование);
+ Возможность использования переменного числа экземпляров (легко изменить класс, чтобы было более одного экзепляра);

### Прототип (Prototype)

**Прототип** - порождающий паттерн, который позволяет системе создавать объекты через клонирования некоторого объекта-прототипа с возможностью модификации клона.

Пусть есть интерфейс и две имплементации вида:

```python
class Prototype(Protocol):
    def clone(self) -> Prototype:
        ...

    def change(self, x: int) -> int:
        ...

    def get_result(self) -> int:
        ...

class ConcretePrototype1(Prototype):
    def __init__(self, x: int) -> None:
        self._x = x

    def clone(self) -> ConcretePrototype1:
        return self.__class__(x=self._x)

    def change(self, x: int) -> int:
        self._x = x

    def get_result(self) -> int:
        return self._x + 1

class ConcretePrototype2(Prototype):
    def __init__(self, x: int, y: int) -> None:
        self._x = x
        self._y = y

    def clone(self) -> ConcretePrototype2:
        return self.__class__(x=self._x, y=self._y)

    def change(self, x: int) -> int:
        self._x = x

    def get_result(self) -> int:
        return self._x + self._y
```

И есть клиент, работающий с прототипом:

```python
class Client:
    def __init__(self, prototype: Prototype) -> None:
        self._prototype = prototype

    def create(self, x: int) -> Prototype:
        new_obj = self._prototype.clone()
        new_obj.change(x=x)
        return new_obj
```

Тогда можно использовать классы-прототипы следующим образом:

```python
>>> client1 = Client(ConcretePrototype1(x=1))
>>> new_1 = client1.create(7)
>>> new_2 = client1.create(9)
>>> new_1.get_result()
7
>>> new_2.get_result()
9
>>> client2 = Client(ConcretePrototype2(x=1, y=2))
>>> new_3 = client2.create(3)
>>> new_3.get_result()
5
>>> new_3 = client2.create(4)
>>> new_4.get_result()
6
```

Преимущества паттерна:

+ Добавление и удаление продуктов во время выполнения через регистрацию на стороне клиента;
+ Определение новых объектов путем изменения значений (де-факто, убирая необходимость в создании дополнительных классов);
+ Динамическая настройка конфигурации приложения классами.

Единственная проблема - необходимость реализации функции клонирования, что не всегда легко, особенно если во внутреннем представлении объекта присутствуют другие некопируемые объекты или циклические ссылки, но в большинстве случаев вопросы являются решаемыми.

### Строитель (Builder)

Строитель - порождающий паттерн, который отделяет логику создания сложного объекта от самого объекта таким образом, чтобы эта же логика могла быть использована для построения абсолютно разных объектов.

Пусть есть некоторый класс, который необходимо сконструировать, и класс, который создает необходимый объект:

```python
class Product:
   def __init__(self) -> None:
       self._parts: List[str] = []

   def add_part(self, part: str) -> None:
       self._parts.append(part)

   def get_parts(self) -> List[str]:
       return self._parts

class ConcreteBuilder:
    def __init__(self) -> None:
        self.product = Product()

    def build_part_a(self) -> None:
        self.product.add_part("part A")

    def build_part_b(self) -> None:
        self.product.add_part("part B")

    def get_result(self) -> Product:
        return self.product
```

Логикой конструирования объекта пользуется класс **Director**, обладая интерфейсом **Builder**:

```python
class Builder(Protocol):
    def build_part_a(self) -> None:
        ...

    def build_part_b(self) -> None:
        ...

    def get_result(self) -> Product:
        ...


class Director:
    def __init__(self, builder: Builder) -> None:
        self._builder = builder

    def construct() -> None:
        self._builder.build_part_a()
        self._builder.build_part_b()
```

При такой конфигурации следующий код работает нормально:

```python
>>> builder = ConcreteBuilder()
>>> director = Director(builder)
>>> director.construct(builder)
>>> product = builder.get_result()
>>> product.get_parts()
["part A", "part B"]
```

Преимущества паттерна:

+ Паттерн позволяет легко изменять внутреннее представление продукта благодаря разбиению процесса создания объекта на несколько шагов.
+ Разделение создания продукта и самого продукта делает имплементацию целевого класса проще.

Единственный недостаток - излишняя сложность и дополнительные классы.

### Фабричный метод (Factory Method)

**Фабричный метод** - порождающий паттерн, целью которого является делегирование создания различных объектов, которые обладают одним интерфейсом. При этом классу, использующему данный паттерн, заранее не известно, объекты каких классов ему нужно создавать.

Имплементация выглядит следующим образом: определяется интерфейс **Creator**, который описывает создание объектов по интерфейсу **Product**:

```python
class Creator(Protocol):
    def factory_method(self) -> Product:
        ...

class Product(Protocol):
    def product_method(self):
        ...
```

В данном контексте, классы, которые удовлетворяют интерфейсу *Creator*, должны имплементировать метод `factory_method()`, который возвращает объект класса, подходящего под *Product*. Тогда функция-клиент, которая использует фабричный метод "создателя", может выглядеть следующим образом:

```python
def client_function(creator: Creator) -> int:
    product = creator.factory_method()
    return product.product_method()
```

Клиентская функция **заранее не знает** о типе продукта, который будет создан и впоследствии использован, тем самым освобождаясь от необходимости знать детали реализации.

Таким же способом можно создать семейство классов-создателей и классов-продуктов:

```python
class ConcreteCreatorA:
    def factory_method(self) -> ConcreteProductA:
        return ConcreteProductA()

class ConcreteProductA:
    def product_method(self) -> int:
        return 0

class ConcreteCreatorB:
    def factory_method(self) -> ConcreteProductB:
        return ConcreteProductB()

class ConcreteProductB:
    def product_method(self) -> int:
        return 1
```

И все вышеописанные классы могут использоваться клиентской функцией, к примеру:

```python
>>> creator_a = ConcreteCreatorA()
>>> creator_b = ConcreteCreatorB()
>>> client_function(creator_a)
0
>>> client_function(creator_b)
1
```

Преимущества паттерна:

+ Подклассам предоставляются **операции-зацепки (hooks)**, которые позволяют подклассам предоставлять расширенной версии объекта.
+ Паттерн позволяет соединять параллельные иерархии в единое и взаимосвязанное целое.

Потенциальный недостаток - необъодимость создания нового класса-создателя для каждого нового класса-продукта.

### Абстрактная фабрика (Abstract Factory)

**Абстрактная фабрика** - порождающий паттерн, который используется для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. По сути, это дополнительный уровень абстракции или обобщение паттерна "фабричный метод".

Реализуется паттерн следующим образом: сначала определяются интерфейсы для фабрик и всех ассоциированных типов продуктов.

```python
class AbstractFactory(Protocol):
    def create_product_a(self) -> AbstractProductA:
        ...

    def create_product_b(self) -> AbstractProductB:
        ...

class AbstractProductA(Protocol):
    def get_int(self) -> int:
        ...

class AbstractProductB(Protocol):
    def get_str(self) -> str:
        ...

```

Клиентский код при использовании паттерна может выглядеть так:

```python
def client_function(factory: AbstractFactory) -> None:
    product_a = factory.create_product_a()
    product_b = factory.create_product_b()
    print(product_b.get_str() * product_a.get_int())
```

При такой конфигурации можно реализовать различные классы-фабрики и классы-продукты,, например:

```python
class ConcreteFactory1:
    def create_product_a(self) -> ConcreteProductA1:
        return ConcreteProductA1()

    def create_product_b(self) -> ConcreteProductB1:
        return ConcreteProductB1()

class ConcreteProductA1:
    def get_int(self) -> int:
        return 1

class ConcreteProductB1:
    def get_str(self) -> str:
        return "b1"


class ConcreteFactory2:
    def create_product_a(self) -> ConcreteProductA2:
        return ConcreteProductA2()

    def create_product_b(self) -> ConcreteProductB2:
        return ConcreteProductB2()

class ConcreteProductA2:
    def get_int(self) -> int:
        return 2

class ConcreteProductB1:
    def get_str(self) -> str:
        return "b2"
```

Вышеописанная структура позволяет следующему коду работать корректно:

```python
>>> factory_1 = ConcreteFactory1()
>>> factory_2 = ConcreteFactory2()
>>> client_function(factory_1)
b1
>>> client_function(factory_2)
b2b2
```

Преимущества паттерна:

+ Все преимущества паттерна "фабричный метод" применимы и к абстрактной фабрике;
+ Абстрактная фабрика изолирует конкретные классы и делает их контролируемыми;
+ Гарантирует сочетаемость продуктов и упрощает замену семейств продуктов.

Недостатки паттерна проявляются в ситуации, когда требуется выполнить операцию, зависящую от подкласса: через абстрактный интерфейс это сделать проблематично и порой невозможно из-за часто встречающихся проблем с безопасностью.

## Структурные паттерны

